# -*- coding: utf-8 -*-
"""salt_identification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15wQR9WwSP-jDfDsBhPF9SnqJP8CKAPmV
"""

import torch
print(torch.cuda.is_available())

# Commented out IPython magic to ensure Python compatibility.
# %%writefile requirements.txt
# torch
# torchvision
# opencv-python
# numpy
# matplotlib
# tqdm
#

!ls

!pip install torch torchvision opencv-python matplotlib tqdm

!pip install kaggle

import os
os.environ['KAGGLE_API_TOKEN'] = 'KGAT_202332d75653070c76dc123020e2fe7b'

!kaggle competitions download -c tgs-salt-identification-challenge

!mkdir -p /root/.config/kaggle

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# cat > /root/.config/kaggle/kaggle.json << 'EOF'
# {
#   "username": "mahbubalam07",
#   "key": "KGAT_202332d75653070c76dc123020e2fe7b"
# }
# EOF
#

!chmod 600 /root/.config/kaggle/kaggle.json

!kaggle competitions download -c tgs-salt-identification-challenge

!kaggle competitions download -c tgs-salt-identification-challenge

!kaggle competitions download -c tgs-salt-identification-challenge

!unzip tgs-salt-identification-challenge.zip

!unzip train.zip
!unzip test.zip

import cv2
import matplotlib.pyplot as plt

# pick one image name
img_name = 'a3df74dd31.png'  # any name you saw during unzip

img = cv2.imread(f'train/images/{img_name}', 0)
mask = cv2.imread(f'train/masks/{img_name}', 0)

plt.figure(figsize=(8,4))

plt.subplot(1,2,1)
plt.imshow(img, cmap='gray')
plt.title('Seismic Image')
plt.axis('off')

plt.subplot(1,2,2)
plt.imshow(mask, cmap='gray')
plt.title('Salt Mask')
plt.axis('off')

plt.show()

import cv2
import matplotlib.pyplot as plt

# choose one image that exists
img_name = 'a3df74dd31.png'  # if this fails, we will change it

# load image and mask
img = cv2.imread(f'train/images/{img_name}', 0)
mask = cv2.imread(f'train/masks/{img_name}', 0)

print(img.shape, mask.shape)  # quick check

# plot
plt.figure(figsize=(8,4))

plt.subplot(1,2,1)
plt.imshow(img, cmap='gray')
plt.title('Seismic Image')
plt.axis('off')

plt.subplot(1,2,2)
plt.imshow(mask, cmap='gray')
plt.title('Salt Mask')
plt.axis('off')

plt.show()

import os

# list first 5 image names
os.listdir('train/images')[:5]

!ls

import cv2
import matplotlib.pyplot as plt
import os

# pick one image automatically
img_name = os.listdir('images')[0]

img = cv2.imread(f'images/{img_name}', 0)
mask = cv2.imread(f'masks/{img_name}', 0)

print("Image shape:", img.shape)
print("Mask shape:", mask.shape)

plt.figure(figsize=(8,4))

plt.subplot(1,2,1)
plt.imshow(img, cmap='gray')
plt.title('Seismic Image')
plt.axis('off')

plt.subplot(1,2,2)
plt.imshow(mask, cmap='gray')
plt.title('Salt Mask')
plt.axis('off')

plt.show()

import cv2
import matplotlib.pyplot as plt
import os

# pick one image automatically
img_name = os.listdir('images')[0]

img = cv2.imread(f'images/{img_name}', 0)
mask = cv2.imread(f'masks/{img_name}', 0)

print("Image shape:", img.shape)
print("Mask shape:", mask.shape)

plt.figure(figsize=(8,4))

plt.subplot(1,2,1)
plt.imshow(img, cmap='gray')
plt.title('Seismic Image')
plt.axis('off')

plt.subplot(1,2,2)
plt.imshow(mask, cmap='gray')
plt.title('Salt Mask')
plt.axis('off')

plt.show()

import os

os.listdir('masks')[:5]

import os
import cv2
import matplotlib.pyplot as plt

# find common filenames
image_files = set(os.listdir('images'))
mask_files = set(os.listdir('masks'))

common_files = list(image_files.intersection(mask_files))

print("Number of matching image-mask pairs:", len(common_files))

# pick one valid file
img_name = common_files[0]
print("Using file:", img_name)

# load image and mask
img = cv2.imread(f'images/{img_name}', 0)
mask = cv2.imread(f'masks/{img_name}', 0)

# plot
plt.figure(figsize=(8,4))

import cv2
import numpy as np

def preprocess(image):
    image = cv2.resize(image, (128, 128))
    image = image / 255.0
    return image

import os
import cv2

# get one matching filename
image_files = set(os.listdir('images'))
mask_files = set(os.listdir('masks'))
common_files = list(image_files.intersection(mask_files))

img_name = common_files[0]

# load raw image and mask
img = cv2.imread(f'images/{img_name}', 0)
mask = cv2.imread(f'masks/{img_name}', 0)

# preprocess
img_p = preprocess(img)
mask_p = preprocess(mask)

print("Processed image shape:", img_p.shape)
print("Processed mask shape:", mask_p.shape)
print("Image min/max:", img_p.min(), img_p.max())

import torch

# convert to torch tensors
img_tensor = torch.tensor(img_p).unsqueeze(0).float()
mask_tensor = torch.tensor(mask_p).unsqueeze(0).float()

print("Image tensor shape:", img_tensor.shape)
print("Mask tensor shape:", mask_tensor.shape)
print("Tensor type:", img_tensor.dtype)

import torch.nn as nn

class SimpleCNN(nn.Module):
    def __init__(self):
        super(SimpleCNN, self).__init__()
        self.conv1 = nn.Conv2d(1, 8, kernel_size=3, padding=1)
        self.relu = nn.ReLU()
        self.conv2 = nn.Conv2d(8, 1, kernel_size=3, padding=1)

    def forward(self, x):
        x = self.conv1(x)
        x = self.relu(x)
        x = self.conv2(x)
        return x

model = SimpleCNN()
print(model)

# forward pass (no training)
output = model(img_tensor.unsqueeze(0))

print("Input shape :", img_tensor.unsqueeze(0).shape)
print("Output shape:", output.shape)

import torch.optim as optim

# loss function and optimizer
criterion = nn.BCEWithLogitsLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# training mode
model.train()

# one training step
optimizer.zero_grad()
output = model(img_tensor.unsqueeze(0))
loss = criterion(output, mask_tensor.unsqueeze(0))
loss.backward()
optimizer.step()

print("Training loss:", loss.item())